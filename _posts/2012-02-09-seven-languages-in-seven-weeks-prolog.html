---
layout: post
title: 'Seven Languages in Seven Weeks: Prolog, Day 1'
date: '2012-02-09T14:21:00.000-08:00'
author: Yevgeniy Brikman
tags:
- Seven Languages in Seven Weeks
- Software Engineering
modified_time: '2012-02-11T19:47:00.415-08:00'
blogger_id: tag:blogger.com,1999:blog-5422014336627804072.post-1892100088835483576
blogger_orig_url: http://brikis98.blogspot.com/2012/02/seven-languages-in-seven-weeks-prolog.html
---

After finishing up <a href="http://en.wikipedia.org/wiki/Prolog">Io</a>, it's time to shift gears yet again in my <a href="http://brikis98.blogspot.com/search/label/Seven%20Languages%20in%20Seven%20Weeks">Seven Languages in Seven Weeks</a> series of blog posts. This time, it's time for something radically different: <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>.<br /><br /><b><span style="font-size: x-large;">Prolog, Day 1: Thoughts</span></b><br /><br />The main goals of <a href="http://pragprog.com/book/btlang/seven-languages-in-seven-weeks">Seven Languages in Seven Weeks</a> is not actually to teach you seven new&nbsp;<i>languages</i>, but to teach you seven new ways of <i>thinking</i>. In fact, the languages in the book are deliberately chosen so as to represent a wide spectrum of approaches to programming problems.<br /><br />While the first two languages, <a href="http://brikis98.blogspot.com/2012/02/seven-languages-in-seven-weeks-io-day-1.html">Ruby</a> and <a href="http://brikis98.blogspot.com/2012/01/seven-languages-in-seven-weeks-ruby-day.html">Io</a>, felt pretty familiar, the third one is a totally different kind of beast. <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a> is my first exposure to <a href="http://en.wikipedia.org/wiki/Declarative_programming">declarative programming</a>&nbsp;and definitely a new way of thinking. All the previous languages followed an imperative model: you write code to tell the compiler what to do one step at a time to arrive at some result. In declarative programming, you actually start by describing the result you want and the compiler figures out the steps to get you there.<br /><br />As an example, consider sorting a collection of integers. In an imperative language, you would describe all the steps of a sorting algorithm:<br /><ol><li>Divide the collection into sublists of size 1.</li><li>Merge pairs of sublists together into a new sublist, keeping the values in sorted order.</li><li>Continue merging the larger sublists together until there is only 1 list remaining.</li></ol>With declarative programming, you would instead describe what the output list should look like:<br /><ol><li>It has every element in the original list.</li><li>Each value at position <i>i</i>&nbsp;in the output list is less than or equal to the value at position <i>i + 1.</i></li></ol>And that's it. The prolog compiler would take this description and figure out how to assemble a list that matches your description.<br /><br />Well, that's the theory any way. After the first chapter, I've only gotten a small taste of this model of programming, so I'm still finding it hard to understand (a) how hard it would be to describe something more complicated than sorting and (b) if the compiler could come up with efficient solutions.<br /><br />Nevertheless, many of us have been using a (limited, non-turing complete) form of declarative programming for years: HTML. Instead of writing procedural code that instructs the browser how to render the page pixel by pixel, HTML lets you describe what the result should look like and the browser figures out how to render it for you.<br /><br /><b><span style="font-size: x-large;">Prolog, Day 1: Problems</span></b><br /><br /><b>Books and authors</b><br /><br />Make a simple knowledge base representing some of your favorite books and authors. Find all books in your knowledge base written by one author. <br /><br />Knowledge base:<br /><br /><script src="https://gist.github.com/1778586.js?file=books.prolog"></script><br />Queries:<br /><br /><script src="https://gist.github.com/1778586.js?file=books_queries.txt"></script><br /><b>Music and instruments</b><br /><br />Make a knowledge base representing musicians and instruments. Also represent musicians and their genre of music. Find all musicians who play the guitar.<br /><br />Knowledge base: <br /><br /><script src="https://gist.github.com/1778586.js?file=music.prolog"></script><br />Queries: <br /><br /><script src="https://gist.github.com/1778586.js?file=music_queries.txt"></script><br /><span style="font-size: x-large;"><b>Normalization</b></span><b><span style="font-size: x-large;">? </span></b><br /><br />For the <a href="https://gist.github.com/1778586#file_books.prolog">books knowledge base</a>, I defined the rules in a "<a href="http://en.wikipedia.org/wiki/Database_normalization">normalized</a>" style as I might use for a SQL database. Looking back at it now, I'm not sure this is the best way to do it. It doesn't seem like I can do anything meaningful with the "normalized" rules other than, perhaps, checking if a given atom is valid.<br /><br />For the <a href="https://gist.github.com/1778586#file_music.prolog">music knowledge base</a>, I only defined the relationships and not any individual atoms. This seems closer to the style in the book and can field the same queries, but with less code. I would hazard a guess that this is the proper way to do it, but I'd love to hear back from anyone who has had more than 1 day of exposure to Prolog. <br /><br /><b><span style="font-size: x-large;">Day 2 </span></b><br /><br />For more Prolog goodness, continue on to <a href="http://brikis98.blogspot.com/2012/02/seven-languages-in-seven-weeks-prolog_11.html">Prolog, Day 2</a>.