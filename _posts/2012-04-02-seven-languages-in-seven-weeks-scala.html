---
layout: post
title: 'Seven Languages in Seven Weeks: Scala, Day 3'
date: '2012-04-02T00:33:00.000-07:00'
author: Yevgeniy Brikman
tags:
- Seven Languages in Seven Weeks
- Software Engineering
modified_time: '2012-11-04T18:58:24.492-08:00'
thumbnail: http://3.bp.blogspot.com/-bxGA8Izcc9k/T3lPptpD7HI/AAAAAAAAKmI/HGYWUo1piv4/s72-c/googleproduct.jpg
blogger_id: tag:blogger.com,1999:blog-5422014336627804072.post-3718526112325970709
blogger_orig_url: http://brikis98.blogspot.com/2012/04/seven-languages-in-seven-weeks-scala.html
---

After some functional programming on <a href="http://brikis98.blogspot.com/2012/03/seven-languages-in-seven-weeks-scala_19.html">day two</a>, it's time for the third and final day of Scala in <a href="http://brikis98.blogspot.com/search/label/Seven%20Languages%20in%20Seven%20Weeks">Seven Languages in Seven Weeks</a>.<br /><br /><b><span style="font-size: x-large;">Scala, Day 3: Thoughts </span></b><br /><br />After two lengthy chapters on the object oriented and functional programming syntax/options in Scala, the third day rushes through some of the most intriguing features, including pattern matching and concurrency via actors. I would have preferred to spend a bit more time on these complicated topics.<br /><br />In fact, I had the same complaint on <a href="http://brikis98.blogspot.com/2012/02/seven-languages-in-seven-weeks-io-day-3.html">Day 3 of IO</a>, where we also blasted through a discussion of concurrency in just a few pages. I respect the difficulties of plowing through seven different languages in a single book and don't expect deep discussions of any one of them, but I think the book would've been stronger if it had a greater bias towards the more advanced "day 3" topics of each language instead of basic syntax discussions in day 1 or 2.<br /><br /><b><span style="font-size: x-large;">Scala, Day 3: Problems</span></b><br /><br /><b>Extend the "sizer" application to count and size links</b><br /><br />Take the sizer application (<a href="https://gist.github.com/2278236#file_sizer.scala">code</a>, <a href="https://gist.github.com/2278236#file_sizer_output.txt">output</a>) and add a message to count the number of links on a page. Follow these links and calculate their size as well, so you get the total size for each page.<br /><br />The code: <br /><br /><script src="https://gist.github.com/2278236.js?file=crawler.scala"></script> The output: <br /><br /><script src="https://gist.github.com/2278236.js?file=crawler_output.txt"></script> This problem was a great way to experiment with actors in Scala. The sequential solution is self explanatory, so here's an outline of the concurrent one: <br /><br /><ol><li>The <i>caller</i> creates B <i>Base Actors</i>, one for each of the B base URLs.</li><li>The <i>caller</i>&nbsp;then&nbsp;calls <i>receive</i> to await a message from each <i>Base Actor</i>.</li><li>Each <i>Base Actor</i> concurrently loads its base URL, finds the links on the page, and creates L <i>Link Actors</i>, one for each of the L links on the page.</li><li>The <i>Base Actor</i>&nbsp;then calls receive to await a message from each of its <i>Link Actors</i>.</li><li>Each <i>Link Actor</i>&nbsp;concurrently loads the page for its given link and sends a message to its parent <i>Base Actor</i>&nbsp;with the size of that page.</li><li>When the <i>Base Actor</i>&nbsp;has received a message form each of his&nbsp;<i>Link Actors</i>, it sends a message to the <i>caller</i>&nbsp;with the total size.</li><li>When the <i>caller</i>&nbsp;has received B messages from the <i>Base Actors</i>, we are done.</li></ol><br />The sequential code takes nearly 20 seconds to run while the concurrent code takes less than 3 seconds, a 7x improvement. The concurrent code is definitely more complicated, but not unreasonably so. Even though it was my first time using Scala actors, the code took less than 30 minutes to get working, much of it spent learning about the <i>self</i>&nbsp;keyword.&nbsp;In fact, I find it very easy to reason about Scala's actors, which is not something I can say for Java's <i>synchronized </i>keyword<i>, </i>Executors, Runnable, and various other concurrency constructs.&nbsp; <br /><br /><div><b><span style="font-size: x-large;">Wrapping up Scala</span></b></div><div><br /></div><div>I'm a bit torn when it comes to Scala. Most of the time, I saw it as a vastly improved version of Java. The support for closures, functional programming, pattern matching, and actors all seem like genuinely useful tools that would <i>dramatically</i> improve productivity, code readability, correctness, and expressiveness. I've already used Scala in a few of my projects to build some features that would've been nearly impossible or incredibly ugly in Java.&nbsp;</div><div><br /></div><div>However, even in my limited exposure to Scala, I've already come across a number of hiccups.&nbsp;As I mentioned on <a href="http://brikis98.blogspot.com/2012/03/seven-languages-in-seven-weeks-scala.html">day 1</a>, the API docs are not helpful and look like they are written for academics. The IDE support is vastly inferior compared to Java. I've now tried both Eclipse and IntelliJ, and each one has significant problems: e.g. missing compile errors on some code; finding errors on other code that's actually valid; broken/missing auto complete; issues with the refactor/rename functionality; poor support for running scripts. The compiler is slow. The type&nbsp;hierarchies&nbsp;are complicated. Type inference doesn't always work as well as you'd hope. &nbsp;</div><div><br /></div><div>However, there is one issue that worries me above all else: feature overload. It seems like Scala is trying to be all things to all people. It's object oriented; it's functional; it has type inference; it has lots of syntactic sugar; it has actors; it's compatible with Java; it has first class support for XML; they are even trying to add <a href="http://scalamacros.org/">macros</a>. While all of these features could lead to an incredibly powerful language, they could also lead to one that's incredibly complicated and difficult to use.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-bxGA8Izcc9k/T3lPptpD7HI/AAAAAAAAKmI/HGYWUo1piv4/s1600/googleproduct.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://3.bp.blogspot.com/-bxGA8Izcc9k/T3lPptpD7HI/AAAAAAAAKmI/HGYWUo1piv4/s400/googleproduct.jpg" width="206" /></a></div><div><br /></div>User experience counts. Not only for products, but for programming languages too.<br /><br />How many features can you pile into one language before it becomes too cumbersome? How much&nbsp;<a href="http://stackoverflow.com/questions/2662984/what-are-all-the-instances-of-syntactic-sugar-in-scala">syntax sugar</a> do you need to understand to be able to read or write code?&nbsp;How many paradigms and mental models do I need to juggle to follow along?&nbsp;Do so many options make a language more flexible or less? Will there be such a thing as "idiomatic Scala" or will it be a free-for-all? Is it better to have a dozen ways to do something or one "proper" and well known way?<br /><br />I don't know the answers to these questions, but I suspect they'll have a large impact on Scala's adoption. In the meantime, I'll keep hacking away at it to see what I can learn.<br /><br /><b><span style="font-size: x-large;">On to Erlang</span></b><br /><br />Read on to learn about the next language in the book, <a href="http://brikis98.blogspot.com/2012/11/seven-languages-in-seven-weeks-erlang.html">Erlang</a>.