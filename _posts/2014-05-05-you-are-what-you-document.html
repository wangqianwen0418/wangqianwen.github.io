---
layout: post
title: You are what you document
date: '2014-05-05T08:53:00.000-07:00'
author: Yevgeniy Brikman
tags:
- Software Engineering
modified_time: '2014-05-17T14:34:49.495-07:00'
thumbnail: http://3.bp.blogspot.com/-s2zNp8ocKJY/U2QnUdUSzUI/AAAAAAAASA4/EB2BVdNQIjc/s72-c/35788628.jpg
blogger_id: tag:blogger.com,1999:blog-5422014336627804072.post-6152165523247681343
blogger_orig_url: http://brikis98.blogspot.com/2014/05/you-are-what-you-document.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-s2zNp8ocKJY/U2QnUdUSzUI/AAAAAAAASA4/EB2BVdNQIjc/s1600/35788628.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-s2zNp8ocKJY/U2QnUdUSzUI/AAAAAAAASA4/EB2BVdNQIjc/s1600/35788628.jpg" height="229" width="320" /></a></div><br />Hey, grab a seat - we need to talk about documentation. Now, I know what you're thinking: documentation is tedious, a chore, an afterthought, a redundant source of information given your beautiful, self-documenting code. It's just like a good diet and exercise - you'll do it when you have the time!<br /><br />Well, this blog post is an intervention. You're hurting others and you're hurting yourself. You poured countless hours into a project, but your co-workers won't use it. You tried to run it in production, but the OPs team won't support it. You put the project on Github, but the fools on Hacker News just don't see the brilliance of what you've done.<br /><br /><a href="http://blakemasters.com/post/22405055017/peter-thiels-cs183-startup-class-9-notes-essay">The number one cause of startup failure is not the product, but the distribution</a>: it doesn't matter how good the product is if no one uses it. With software, <i>the documentation is the distribution</i>: it doesn't matter how good the code is if no one uses it.&nbsp;<a href="http://www.mikepope.com/blog/DisplayBlog.aspx?permalink=1680">If it isn't documented, it doesn't exist</a>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-fEUB5ZWaTj8/U2Qp_9CmMEI/AAAAAAAASBE/MlhBV-uvF_Y/s1600/45420873.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-fEUB5ZWaTj8/U2Qp_9CmMEI/AAAAAAAASBE/MlhBV-uvF_Y/s1600/45420873.jpg" /></a></div><br />Think of this blog post as documentation for your documentation<i>.</i>&nbsp;By "documentation", I don't just mean a written manual, but all the pieces that go into making your software <i>learnable</i>: the coding practices,&nbsp;tutorials, white papers, marketing, the community, and the user experience.<br /><br />I'll be discussing three types of documentation:<br /><ol><li><b>Written documentation</b>: READMEs, tutorials, reference guides, white papers.</li><li><b>Code documentation</b>: API docs, comments, example code, the type system.</li><li><b>Community documentation</b>: blog posts, Q&amp;A sites, talks, meetup groups.</li></ol>Each type of documentation solves a different problem, so most projects should include some mix of all three types. I've tried to include links to open source projects that best demonstrate each of the different types of documentation. If you know of other great examples or other types of documentation that I've missed, please leave a comment.<br /><br /><b><span style="font-size: x-large;">1. Written documentation</span></b><br /><br />Let's start with what people typically think of when they hear the word "documentation": READMEs, tutorials, reference guides, etc.<br /><br /><b><span style="font-size: large;">1a. The README</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://github.com/twitter/hogan.js"><img border="0" src="http://2.bp.blogspot.com/-H-XOTLWa-t4/U2Req8ocNEI/AAAAAAAASBs/ZY5U-hGM5MA/s1600/Screen+Shot+2014-05-02+at+8.12.30+PM.png" height="293" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"></div>Every project should have a README: it is the <a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">single most important document in your codebase</a>. The README is typically your first contact with a new user, so your goal is to introduce them to the project as quickly as possible, convince them why it's worth learning more, and give them pointers on how to get started and where to get more info.<br /><br />A typical README should have the following information:<br /><ol><li><b>Description</b>: short "sales pitch". Tell the reader why they should keep reading.</li><li><b>Quick examples</b>:<b> </b>short code snippets or screenshots to support the description.</li><li><b>Quick start</b>: how to get going, install instructions, and more examples.</li><li><b>Further documentation</b>: links to the full docs and more info.</li><li><b>Project organization</b>: who are the authors, how to contribute, how to file bugs.</li><li><b>Legal notices</b>: license, copyright, and any other legal details.</li></ol>Here are some examples of great README's:<br /><ol><li><a href="https://github.com/twbs/bootstrap">Twitter Bootstrap</a></li><li><a href="https://github.com/guard/guard">guard</a></li><li><a href="https://github.com/ajaxorg/ace">Ace</a></li><li><a href="https://github.com/jekyll/jekyll">jekyll</a></li><li><a href="https://github.com/twitter/hogan.js">hogan.js</a></li><li><a href="https://github.com/emberjs/ember.js">ember.js</a></li></ol><div>I usually practice&nbsp;<a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Readme Driven Development</a>, writing the README before writing any code. This forces me to be clear on exactly what I'm trying to build, helps me prioritize the work (anything in the "sales pitch" is a must-have), and provides a great sanity check on what the basic user experience looks like (the quick example and quick start sections are essential). See the original&nbsp;<a href="http://tom.preston-werner.com/2010/08/23/readme-driven-development.html">Readme Driven Development</a>&nbsp;post and&nbsp;<a href="http://zachholman.com/posts/documentation/">The Most Important Code Isn't Code</a>&nbsp;for more info.</div><div><br /></div><b><span style="font-size: large;">1b. Tutorials, walkthroughs, and guides</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://tour.golang.org/"><img border="0" src="http://2.bp.blogspot.com/-HsyX6KFZ6QI/U2adnkoIbVI/AAAAAAAASF0/taQacf-MOqI/s1600/Screen+Shot+2014-05-04+at+1.05.34+PM.png" height="306" width="320" /></a></div>The README gets the user in the door; the tutorial shows them how to walk around. The goal is to guide a new user through example use cases that highlight the idiomatic patterns, the best practices, and the unique features of the project. Use the tutorial to have a dialogue with the user, walking them through the typical development flow step by step and introducing the key ideas. You don't have to cover every single topic and you don't have to go too in-depth: instead, at each step of the tutorial, provide links to where the user can find more info.<br /><br />For small, simple projects, you may be able to squeeze a tutorial into the README itself, but most projects will want to use a wiki, a blog post, a standalone webpage, slide deck, or even a recorded video. Here are some great examples:<br /><ol><li><a href="http://guides.rubyonrails.org/">Ruby on Rails Guides</a></li><li><a href="https://docs.djangoproject.com/en/1.3/intro/tutorial01/">Django Tutorial</a></li><li><a href="https://dropwizard.github.io/dropwizard/getting-started.html">Dropwizard Getting Started</a></li><li><a href="http://vimeo.com/58969923">Intro to Play Framework for Java</a></li><li><a href="http://www.twilio.com/docs/quickstart">Twilio quick start tutorials</a></li></ol>The gold standard, however, is the <i>interactive</i> tutorial. Most developers learn best by doing, so a step-by-step guide that lets the developer participate is the ultimate learning tool. Here are a few great examples:<br /><ol><li><a href="http://tour.golang.org/#1">A Tour of Go</a></li><li><a href="http://scalatutorials.com/">Scala Tutorials</a></li><li><a href="https://typesafe.com/activator">Typesafe Activator</a></li><li><a href="http://try.redis.io/">Try Redis</a> and <a href="http://redis.io/commands">Redis commands</a></li><li><a href="https://try.github.io/">Try Git</a></li><li><a href="http://www.codecademy.com/">Codecademy</a></li></ol><div>Creating your own interactive tutorial is not easy, but it dramatically lowers the bar for trying and learning about your project. Here are some (language/framework specific) tools you may find helpful:&nbsp;<a href="http://io.livecode.ch/">io.livecode.ch</a>, <a href="http://ipython.org/notebook.html">IPython Notebook</a>, <a href="https://github.com/albertlatacz/java-repl">java-repl</a>, <a href="http://pamflet.databinder.net/Pamflet.html">Pamflet</a>, <a href="https://typesafe.com/activator">Typesafe Activator</a>, <a href="https://github.com/replit/repl.it">repl.it</a>, <a href="http://ace.c9.io/">Ace Editor</a>, <a href="http://codemirror.net/">CodeMirror</a>, <a href="https://c9.io/">Cloud9 IDE</a>, <a href="http://jsfiddle.net/">jsfiddle</a>, <a href="http://www.codecademy.com/teach">Codecademy</a>,&nbsp;and <a href="http://codepen.io/">codepen</a>. &nbsp; &nbsp;</div><div><br /></div><b><span style="font-size: large;">1c. Reference documentation</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://docs.djangoproject.com/en/1.6/"><img border="0" src="http://3.bp.blogspot.com/-3ZOS9RuU0Og/U2TJPxt5U_I/AAAAAAAASFc/npni9eqhdXQ/s1600/Screen+Shot+2014-05-03+at+3.47.10+AM.png" height="264" width="320" /></a></div>Ok, your new user got their foot in the door with the README and they took a few steps by following the tutorial; now, the user actually knows enough to start asking questions. This is where the reference documentation comes into play: the goal is to give users a way to <i>find</i> the specific information they need. In this part of the documentation, you can cover all the major topics in depth, but make sure to organize the information in a way that is easy to search and navigate.<br /><br />Here are some great examples of reference documentation:<br /><ol><li><a href="https://stripe.com/docs">Stripe docs</a></li><li><a href="https://docs.djangoproject.com/en/1.3/">Django documentation</a></li><li><a href="https://dropwizard.github.io/dropwizard/manual/index.html">Dropwizard user manual</a></li><li><a href="http://metrics.codahale.com/manual/">Codahale metrics</a></li><li><a href="http://www.sqlite.org/docs.html">SQLite documents</a></li></ol>For large projects, the amount of reference documentation can be pretty large. How do you keep it up to date? One technique is to include references to real code: that is, instead of typing code snippets directly into your docs, build a system to dynamically include them from a real repository.<br /><br />For example, consider this entry in the <a href="http://playframework.com/documentation/2.2.x/ScalaAsync">Play Framework async docs</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-2YmoZPa1wWk/U2RocknVfNI/AAAAAAAASCU/Z3XhwRdaVac/s1600/Screen+Shot+2014-05-02+at+8.53.58+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-2YmoZPa1wWk/U2RocknVfNI/AAAAAAAASCU/Z3XhwRdaVac/s1600/Screen+Shot+2014-05-02+at+8.53.58+PM.png" height="160" width="400" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div>This documentation is generated from markdown files using the <a href="https://github.com/playframework/play-doc">play-doc</a> project. For example, here is the Markdown for the <a href="https://github.com/playframework/playframework/blob/f10274e261329a72112b4a1a9ea83f8c93b27312/documentation/manual/scalaGuide/main/async/ScalaAsync.md#returning-futures">"Returning futures" section</a>:<br /><br /><script src="https://gist.github.com/brikis98/b37fab2e26452877a375.js"></script>Notice that the code snippet is <i>not</i>&nbsp;in the Markdown.&nbsp;Instead, there is just the line&nbsp;<code>@[async-result](code/ScalaAsync.scala),</code> which is a reference to <a href="https://github.com/playframework/playframework/blob/321af079941f64cdd2cf32b407d4026f7e49dfec/documentation/manual/scalaGuide/main/async/code/ScalaAsync.scala#L63">ScalaAsync.scala</a> in Play's git repo, where the relevant code is demarcated using special comments:<br /><br /><script src="https://gist.github.com/brikis98/581bec202b0a622d3c15.js"></script>Since this file is compiled and tested, developers have to update it whenever they make changes to the framework - otherwise, the build fails. Moreover, as the comments identify the section of code as "used in the documentation", there is a good chance the developers will remember to update the relevant part of the documentation as well.<br /><ol></ol><b><span style="font-size: large;">1d. Project websites</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://pages.github.com/"><img border="0" src="http://3.bp.blogspot.com/-J3parWAd8Ys/U2RtNRrP8MI/AAAAAAAASCk/-AuaiM-FF7E/s1600/Screen+Shot+2014-05-02+at+9.14.33+PM.png" height="204" width="320" /></a></div>Standalone project websites are a great example of&nbsp;<a href="http://zachholman.com/posts/open-source-marketing/">documentation as marketing</a>: you can give your project its own home, with a custom look and feel, and content that is linkable, tweetable, and indexable.<br /><br />Here are a few great examples:<br /><ol><li><a href="http://getbootstrap.com/">Bootstrap</a></li><li><a href="http://jekyllrb.com/">jekyll</a></li><li><a href="http://yeoman.io/">Yeoman</a></li><li><a href="http://emberjs.com/">Ember</a></li><li><a href="http://foundation.zurb.com/">Foundation</a></li></ol><div>The easiest way to create a website for your project is with&nbsp;<a href="https://pages.github.com/">Github Pages</a>: create a repo on Github, put a few static HTML files in it (possibly using&nbsp;<a href="http://jekyllrb.com/">jekyll</a>), git push, and you have your own landing page on the github.io domain.</div><div><br /></div><b><span style="font-size: large;">1e. White papers and books</span></b><br /><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683"><img border="0" src="http://1.bp.blogspot.com/-_CiTjt-FHx0/U2TJw1A2VmI/AAAAAAAASFk/vwuVU7CO4iI/s1600/ShowCover.jpeg" height="320" width="254" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br />If you want to make a project look legit, a white paper, and especially a book, is the way to go. White papers are a great way to explain the background for the project: why it was built, the requirements, the approach, and the results. Books, of course, can contain the material in all the sections above: a quick intro, a tutorial, a reference guide, and more. Books are a sign that your project has "made it": there is enough interest in it that a publisher is willing to put money into printing the book and programmers are willing to put money into buying the book.<br /><br />Some great examples:<br /><ol><li><a href="https://bitcoin.org/bitcoin.pdf">Bitcoin: a peer-to-peer electronic cash system</a></li><li><a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-White-Paper">Ethereum white paper</a></li><li><a href="http://research.microsoft.com/en-us/um/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf">Kafka: a distributed messaging system for log processing</a></li><li><a href="http://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628">C Programming Language</a></li><li><a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683">Effective Java</a></li></ol><br /><b><span style="font-size: x-large;">2. Code documentation</span></b><br /><br />We now understand the role of written documentation: the README gets your foot in the door; the tutorial shows you how to walk around; the reference guide is a map. But to truly understand <i>how</i> a piece of software works, you have to <a href="http://blog.codinghorror.com/learn-to-read-the-source-luke/">learn to read the source</a>. As the author of a project, it is your job to make the code as easy to understand as possible: <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">programs must be written for people to read, and only incidentally for machines to execute</a>.<br /><br />However, the code cannot be the <i>only</i> documentation for a project. You can no more learn how to use a complicated piece of software by reading the source than you can <a href="http://stevelosh.com/blog/2013/09/teach-dont-tell/">learn to drive a car by taking apart the engine</a>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-HJ-tQ4OJoLw/U2Se29ztRzI/AAAAAAAASDI/4MpiFO-G-BQ/s1600/Car-Parts.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-HJ-tQ4OJoLw/U2Se29ztRzI/AAAAAAAASDI/4MpiFO-G-BQ/s1600/Car-Parts.jpg" height="207" width="320" /></a></div><br />As we'll discuss below, code structure, comments, API docs, design patterns, and test cases all contain critical information for learning how to use a project, but remember that they are not a replacement for written documentation.<br /><br /><b><span style="font-size: large;">2a. Naming, design patterns, and the type system</span></b><br /><div class="separator" style="clear: both; text-align: center;"><br /></div>There is no such thing as "self documenting" code, but there are ways to make the code easier or harder to understand. One of the first aspects of code readability is naming: every piece of software defines its own mini language or DSL that consists of class names, package names, method names, and variable names. When a developer uses your code, they are really learning a new language, so choose the words in it wisely! However, since <a href="http://martinfowler.com/bliki/TwoHardThings.html">naming is one of the two hardest problems in computer science</a>, I recommend getting yourself a copy of <a href="http://www.cc2e.com/Default.aspx">Code Complete</a>, which dedicates quite a few pages to this topic:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.cc2e.com/Default.aspx"><img border="0" src="http://1.bp.blogspot.com/-AxHHfkBSCq4/U2S7_07OghI/AAAAAAAASEU/jOFLwKblba0/s1600/2352.9780735619678f_6D939405.jpg" height="200" width="163" /></a></div><br /><a href="http://en.wikipedia.org/wiki/Software_design_pattern">Design patterns</a> are another tool for communicating the intent of your code. You have to be careful not to overuse them (see <a href="http://blog.codinghorror.com/rethinking-design-patterns/">Rethinking Design Patterns</a>), but having a shared vocabulary of terms like singleton, factory, decorator, and iterator can be useful in setting expectations and making the naming problem a little easier. The classic book in on this topic is <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a>, aka "The Gang of Four":<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612"><img border="0" src="http://2.bp.blogspot.com/-Zjv66e9LO4c/U2S8EJTlzeI/AAAAAAAASEc/gLIgBMBHZ2o/s1600/6a0120a85dcdae970b012877701400970c-pi.png" height="200" width="152" /></a></div><br />Finally, the type system in statically typed languages can be another powerful source of information. A type system can reduce not only the number of tests you write (by catching a certain class of errors automatically), but also the amount of documentation you have to write. For example, when calling a function in a dynamically typed language, there is no way to know the types of parameters to pass in unless the author of the function manually documented it; in a statically typed language, the types are known automatically, especially with a good IDE.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-iBesxITaYe8/U2S8IeOUiHI/AAAAAAAASEk/BvvDa--r2sM/s1600/602px-haskell-logo.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-iBesxITaYe8/U2S8IeOUiHI/AAAAAAAASEk/BvvDa--r2sM/s1600/602px-haskell-logo.png" height="140" width="200" /></a></div><br />Of course, not all type systems are equal, and you have to use them correctly (e.g. avoid <a href="http://blog.codinghorror.com/new-programming-jargon/">stringly typed programming</a>) to see the benefits. For examples of powerful type systems, check out (in increasing order of power and crazy) <a href="http://www.scala-lang.org/">Scala</a>, <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>, and <a href="http://www.idris-lang.org/">Idris</a>.<br /><b><span style="font-size: large;"><br /></span></b><b><span style="font-size: large;">2b. API docs and literate programming</span></b><br /><br />API docs are documentation for each class, function, and variable in your code. They are a fine-grained form of documentation that lets you learn about the inputs and outputs of each function, the preconditions and postconditions, and, perhaps most importantly, <i>why</i> a certain piece of code exists and behaves the way it does.<br /><br />Many programming languages have tools to generate API docs. For example, Java comes with <a href="http://www.oracle.com/technetwork/java/javase/documentation/javadoc-137458.html">JavaDoc</a>, which lets you add specially formatted comments to the code:<br /><br /><script src="https://gist.github.com/brikis98/3af68cdc37ccd3eeb743.js"></script>You can then run a command line utility that generates a webpage for each class with the JavaDoc comment formatted as HTML:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-JgkdxEMGgcs/U2SerjgtwJI/AAAAAAAASDA/EWAiK7d7PK8/s1600/Screen+Shot+2014-05-03+at+12.45.20+AM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-JgkdxEMGgcs/U2SerjgtwJI/AAAAAAAASDA/EWAiK7d7PK8/s1600/Screen+Shot+2014-05-03+at+12.45.20+AM.png" height="284" width="400" /></a></div><br />Good IDEs can show API docs automatically for any part of the code:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-fhm_uLZP_yI/U2SgfWje19I/AAAAAAAASDU/orxqARRSpWk/s1600/41-javadoc.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-fhm_uLZP_yI/U2SgfWje19I/AAAAAAAASDU/orxqARRSpWk/s1600/41-javadoc.png" height="186" width="400" /></a></div><br />Some frameworks have special handling for API docs as well. For example, <a href="http://rest.li/">rest.li</a> automatically extracts the documentation from your REST service and exposes it in a <a href="https://github.com/linkedin/rest.li-api-hub">web UI</a>. You can use this UI to browse all the RESTful services available, see what resources they expose, what methods and parameters they support, and even make REST calls straight from your browser:<br /><div class="separator" style="clear: both; text-align: center;"></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://github.com/linkedin/rest.li-api-hub"><img border="0" src="http://1.bp.blogspot.com/-HutddWr7q4A/U2Sk1x5cs0I/AAAAAAAASD0/aa_GCcpLxio/s1600/resource-screenshot.png" height="223" width="400" /></a></div><br />Here are a few nice examples of API docs:<br /><ol><li><a href="http://docs.oracle.com/javase/7/docs/api/">Java API docs</a></li><li><a href="http://www.scala-lang.org/api/current/">Scala API docs</a></li><li><a href="https://stripe.com/docs/api">Stripe API docs</a></li><li><a href="http://www.twilio.com/docs/api">Twilio API docs</a></li><li><a href="https://developer.github.com/v3/">Github API docs</a></li><li><a href="https://github.com/linkedin/rest.li-api-hub">rest.li API docs</a></li></ol><a href="http://en.wikipedia.org/wiki/Literate_programming">Literate programming</a> goes even further: the idea is that program logic should be described <i>first</i> in natural language; the code comes second, interspersed amongst the English description where convenient. Instead of organizing programs in a way that's easy for compilers to process (ie, rigid file, folder, and package structure), literate programs should be organized in a way that makes it easier for humans to understand, such as an essay format.<br /><br />I think literate programming is a great concept, but I'm not aware of any mainstream languages that support it fully. The closest I've seen are projects that use tools like <a href="http://jashkenas.github.io/docco/">docco</a>, which lets you generate an HTML page that shows your comments intermingled with the code, and feels like a halfway point between API docs and literate programming. Here's an example from <a href="http://coffeescript.org/documentation/docs/nodes.html">Literate CoffeeScript</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://coffeescript.org/documentation/docs/nodes.html"><img border="0" src="http://3.bp.blogspot.com/-LWDZPdWfnq0/U2ao19V3MuI/AAAAAAAASGE/x4KIj6coKnY/s1600/Screen+Shot+2014-05-04+at+1.52.42+PM.png" height="239" width="320" /></a></div><div class="separator" style="clear: both; text-align: left;">There are flavors of docco tailored for specific languages, such as&nbsp;<a href="http://rtomayko.github.io/rocco/rocco.html">rocco</a> (Ruby), <a href="http://fitzgen.github.io/pycco/">Pycco</a> (Python), <a href="http://nikhilm.github.io/gocco/">Gocco</a> (Go), and&nbsp;<a href="http://rtomayko.github.io/shocco/">shocco</a> (POSIX shell). There is also an extension of docco called <a href="http://nevir.github.io/groc/">Groc</a>, which adds support for a searchable table of contents, handles hierarchies of files and folders, and integrates with Github Pages..</div><ol></ol><b><span style="font-size: large;">2c. Comments</span></b><br /><b><br /></b>When used correctly, comments are another important source of information: whereas the <a href="http://blog.codinghorror.com/code-tells-you-how-comments-tell-you-why/">code tells you how, comments tell you why</a>. The trick is finding the right balance. Code without any <a href="http://queue.acm.org/detail.cfm?id=1053354">comments can't explain why the program is being written</a>, the rationale for choosing this or that method, or the reasons certain alternative approaches were taken;&nbsp;code with too many comments can often be a sign that the code itself is unclear and instead of fixing the code, the <a href="http://sd.jtimothyking.com/2006/12/15/does-bad-writing-reflect-poor-programming-skills/">comments are being used as a crutch</a>.<br /><br />In short: always use comments in moderation and always to explain <i>why</i>.<br /><br />For the "best" examples of comments, I point you to a hilarious StackOverflow thread: <a href="http://stackoverflow.com/questions/184618/what-is-the-best-comment-in-source-code-you-have-ever-encountered/">What is the best comment in source code you have ever encountered?</a><br /><br /><script src="https://gist.github.com/brikis98/c4180e793ae32d1a4dfb.js"></script> <b><span style="font-size: large;">2d. Example code and test code</span></b><br /><br />No matter how good your docs are, you can't force developers to <a href="http://en.wikipedia.org/wiki/RTFM">RTFM</a>. Some developers prefer to learn by example - which is a polite way of saying that they like to copy and paste.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-_HmqG7UIX5E/U2Syabad3TI/AAAAAAAASEE/ic2PwuSmCWM/s1600/b53ad99b8dfae5c65a4a797d95e6bcee.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-_HmqG7UIX5E/U2Syabad3TI/AAAAAAAASEE/ic2PwuSmCWM/s1600/b53ad99b8dfae5c65a4a797d95e6bcee.jpg" height="320" width="320" /></a></div><br />Getting the example code right is critical to the success of a project, as many developers will blindly copy and paste it. Your goal is to make as many clean, idiomatic examples available as possible. You may also want to invest extra time with the first few teams that adopt your project to help them write clean code: their projects may become the models for everyone else, so make sure it's a model that's worth following!<br /><br />Here are some projects with great example code:<br /><ol><li><a href="http://www.twilio.com/docs/howto">Twilio HowTo's and Example Code</a></li><li><a href="http://getbootstrap.com/2.3.2/getting-started.html#examples">Twitter bootstrap examples</a></li><li><a href="https://typesafe.com/activator/templates">Typesafe Activator templates</a></li><li><a href="https://github.com/caolan/async">async.js</a></li><li><a href="https://www.firebase.com/docs/examples.html">Firebase examples</a></li></ol>Automated tests are a special case of example code. Tests can be useful as documentation in that they show the <i>expected</i> behavior of the code for a variety of use cases. <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> style unit tests, such as <a href="http://etorreborre.github.io/specs2/">Specs2</a> and <a href="http://rubydoc.info/gems/rspec-core/frames">RSpec</a>, even encourage writing test cases as a formal specifications. However, in practice, test code can get tangled up with mock objects, test frameworks, and corner cases, all of which can be a source of confusion if you try to rely on it too heavily as a form of documentation.<br /><br />Projects with great test code:<br /><ol><li><a href="http://www.sqlite.org/testing.html">SQLite</a></li><li><a href="http://lucene.apache.org/core/index.html">Apache Lucene</a></li><li><a href="http://backbonejs.org/test/">backbone.js</a></li><li><a href="http://dev.chromium.org/developers/testing">Chromium</a></li><li><a href="http://fireunit.org/jquery/test/">jQuery</a></li></ol><br /><b><span style="font-size: x-large;">3. Community documentation</span></b><br /><br />We've talked about written documentation and code documentation; the final piece of the puzzle comes from the people involved with the project and the tools they use.<br /><br /><span style="font-size: large;"><b>3a. Project management tools</b></span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-p2aUPqRErJM/U2S9KIXM52I/AAAAAAAASEw/M6tdBbVhGT4/s1600/Tps_report.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-p2aUPqRErJM/U2S9KIXM52I/AAAAAAAASEw/M6tdBbVhGT4/s1600/Tps_report.png" height="200" width="154" /></a></div><br />Most teams use bug tracking software (e.g. <a href="https://www.atlassian.com/software/jira">JIRA</a>, <a href="http://www.bugzilla.org/">bugzilla</a>, <a href="https://github.com/blog/831-issues-2-0-the-next-generation">github issues</a>) and/or project management software (e.g. <a href="https://basecamp.com/">Basecamp</a>, <a href="https://asana.com/">Asana</a>, <a href="https://trello.com/">Trello</a>). These systems contain a lot of information about the project: what you worked on before, what you're working on now, what you'll work on in the future, bugs found, bugs fixed, and so on.<br /><br />A few examples:<br /><ol><li><a href="https://github.com/playframework/playframework/issues?state=open">Play Framework Github Issues</a></li><li><a href="https://bugzilla.mozilla.org/">Mozilla Bugzilla</a></li><li><a href="https://wiki.mozilla.org/Firefox/Roadmap">Firefox Roadmap Wiki</a></li><li><a href="https://code.google.com/p/chromium/issues/list">Chromium Issues</a></li></ol><div>It's hard to imagine how a&nbsp;<a href="https://www.youtube.com/watch?v=Fy3rjQGc6lA">TPS report</a>&nbsp;can be useful as documentation, but very often, the discussions over a tricky bug or the requirements gathering before starting a new project contain critical information not available anywhere else. It's not uncommon to come across a bug report or an old wiki page while searching for information about a project, especially if it's an open source project that makes all of this information publicly available.</div><div><br /></div><b><span style="font-size: large;">3b. Mailing lists and Q&amp;A boards</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-diOsUMA8eYU/U2S-JHwBZvI/AAAAAAAASE8/kcaY7ty6Bn0/s1600/so-logo.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-diOsUMA8eYU/U2S-JHwBZvI/AAAAAAAASE8/kcaY7ty6Bn0/s1600/so-logo.png" height="95" width="320" /></a></div><br />Discussions from Q&amp;A sites like <a href="http://stackoverflow.com/">StackOverflow</a> and mailing lists like <a href="https://groups.google.com/forum/#!overview">google groups</a> also come up frequently in search results. Even the best documentation will not be able to answer everything, so cultivating community websites can be a critical part of making software learnable. Over time, these may become some of the most important parts of your project's documentation, as they inherently deal with issues where many developers got stuck.<br /><br />A few examples:<br /><ol><li><a href="https://groups.google.com/forum/#!forum/play-framework">Play Framework Google Group</a></li><li><a href="http://stackoverflow.com/questions/tagged/android">Android StackOverflow Tag</a></li><li><a href="http://stackoverflow.com/questions/tagged/ruby-on-rails">Ruby on Rails StackOverflow Tag</a></li></ol><div>This is one area where open source projects shine: being able to instantly find answers by using google is a huge win. That said, for internal/proprietary projects, I encourage you to setup internal mailing lists, maintain an FAQ, and/or install an&nbsp;<a href="http://meta.stackexchange.com/questions/2267/stack-overflow-clones">internal StackOverflow-style Q&amp;A site</a>&nbsp;within your company.</div><div><br /></div><b><span style="font-size: large;">3c. Blog posts, talks, meetup groups</span></b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-X9MJhDohbZc/U2S-h2HCtxI/AAAAAAAASFE/sRdn2_OG9O8/s1600/logo-2x.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-X9MJhDohbZc/U2S-h2HCtxI/AAAAAAAASFE/sRdn2_OG9O8/s1600/logo-2x.png" /></a></div><br />For popular open source projects, some of the best documentation comes in the form of content contributed by the community. For example, blog posts and talks from end users are a valuable source of information, revealing what's really working and what isn't; they are also great marketing, as it makes it clear other people are using project. Even blog posts that completely trash the project can be useful - think of it as a free design review!<br /><br />If your project is open source, growing a community around it can have a huge pay off. A small investment in "marketing" your project - via good documentation, custom project pages, giving talks, and setting up meetup groups - can yield huge returns in the form of <a href="http://brikis98.blogspot.com/2011/04/open-source.html">free labor, cleaner code, and better branding</a>.<br /><br />There are countless great blog posts and talks, so here are a few unbiased, randomly selected links that you should definitely check out:<br /><ol><li><a href="http://brikis98.blogspot.com/2014/03/the-ultimate-guide-to-getting-started.html">The Ultimate Guide to Getting Started with the Play Framework</a></li><li><a href="http://engineering.linkedin.com/play/composable-and-streamable-play-apps">Composable and Streamable Play Apps</a></li><li><a href="http://engineering.linkedin.com/play/play-framework-linkedin">The Play Framework at LinkedIn</a></li><li><a href="http://www.slideshare.net/brikis98/play-framework-async-io-with-java-and-scala">Play Framework: Async I/O with Java and Scala</a></li><li><a href="http://brikis98.blogspot.com/2014/04/bitcoin-by-analogy.html">Bitcoin by Analogy</a></li></ol><br /><b><span style="font-size: x-large;">Further reading</span></b><br /><br />If you've made it this far, you should now know how, and why, to document your code. I hope you join me in building software that is easier to use and learn.<br /><br />If you're hungry for more info, I recommend the following resources:<br /><span id="docs-internal-guid-c8fedc3e-bc18-e3b2-30df-9cafa7f4ef92"></span><br /><ol style="margin-bottom: 0pt; margin-top: 0pt;"><li><a href="http://jacobian.org/writing/great-documentation/" style="font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: none;"><span style="color: #1155cc; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">Writing Great Documentation</span></a></li><li><a href="http://zachholman.com/posts/documentation/" style="font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: none;"><span style="color: #1155cc; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">The Most Important Code Isn't Code</span></a></li><li><a href="http://stevelosh.com/blog/2013/09/teach-dont-tell/">Teach, Don't Tell</a></li><li><a href="http://blog.parse.com/2012/01/11/designing-great-api-docs/" style="font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: none;"><span style="color: #1155cc; font-size: 15px; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;">Designing Great API Docs</span></a></li><li><span style="color: #1155cc; font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="http://www.mikepope.com/blog/DisplayBlog.aspx?permalink=1680" style="font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: none;">No docs == no product</a></span></li><li><span style="color: #1155cc; font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="https://github.com/PharkMillups/beautiful-docs" style="line-height: 1.15; text-decoration: none;">Pointers to useful, well-written, and otherwise beautiful documentation</a></span></li><li><a href="http://blog.codinghorror.com/if-it-isnt-documented-it-doesnt-exist/">If It Isn't Documented, It Doesn't Exist</a></li><li><span style="color: #1155cc; font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="http://docs.writethedocs.org/writing/beginners-guide-to-docs/" style="line-height: 1.15; text-decoration: none;">A beginners guide to writing documentation</a></span></li><li><span style="color: #1155cc; font-family: Arial; font-size: 15px; line-height: 1.15; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap;"><a href="http://readwrite.com/2010/08/14/tips-for-writing-good-document#awesm=~oCZZHjd5dUD5EN" style="line-height: 1.15; text-decoration: none;">Tips for Writing Good Documentation</a></span></li></ol>